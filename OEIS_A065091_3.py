import math

"""
==========================================================
Number Theory Combinatorial Prime Finder (OEIS A065091)
==========================================================

This script computes a special sequence of numbers in a given 
range [n_start, n_end) using a combinatorial formula based on 
differences of squares:

    x = |a^2 - b^2| 
    y = x * |b - a|

Only numbers for which y == x are considered “valid” and are 
printed along with their index.

The sequence generated by this method corresponds to the odd 
primes in the specified range, as in OEIS A065091.

The script also verifies the output by:

1. Ensuring that all odd primes in the specified range are present 
   in the output.
2. Checking that no composites are included in the output.

Functions:

- compute_max_y(n_start, n_end): Computes max_y(x) for numbers in the range.
- sieve_primes(limit): Returns a boolean list indicating primality up to 'limit'.
- run(n_start, n_end): Generates the numbers, prints results, and verifies output.
- main(): Entry point of the script; sets the range and runs the computation.

Author: Rui Ferreira
Date:   2026-02-10
"""

def compute_max_y(n_start: int, n_end: int) -> dict[int,int]:
    """Compute max_y(x) using the combinatorial formula; return as dict."""
    max_y_per_x = dict()
    n_isqrt = math.isqrt(n_end)
    for a in range(n_end // 2):
        for b in range(a + 1, a + 1 + n_isqrt):
            x = abs(a**2 - b**2)
            y = x * abs(b - a)
            if y == 0:
                continue
            # Only store x if it's within the desired range
            if n_start <= x < n_end:
                if y > max_y_per_x.get(x, 0):
                    max_y_per_x[x] = y
    return max_y_per_x

def sieve_primes(limit: int) -> list[bool]:
    """Return a boolean list where True means prime."""
    if limit < 2:
        return [False] * (limit + 1)
    is_prime = [False, False] + [True] * (limit - 1)
    for i in range(2, int(limit ** 0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, limit + 1, i):
                is_prime[j] = False
    return is_prime

def run(n_start: int, n_end: int) -> None:
    max_y_per_x = compute_max_y(n_start, n_end)

    print(f"x → max_y(x) (numbers from {n_start} to {n_end}):\n")

    found_numbers = []
    idx = 0
    for x in sorted(max_y_per_x.keys()):
        if x == 1:
            continue
        y = max_y_per_x[x]
        if y != x:
            continue
        idx += 1
        found_numbers.append(x)
        print(f"[{idx:6d}] {y:6d}")

    print(f"\n✅ Reached x ≥ {n_end}. All numbers in range have been listed.\n")

    # --- Verification ---
    is_prime = sieve_primes(n_end)
    missing_primes = []
    composites_found = []

    for x in found_numbers:
        if x >= n_end:
            continue
        if x == 2:
            continue  # optionally ignore 2
        if not is_prime[x]:
            composites_found.append(x)

    for p in range(max(3, n_start), n_end, 2):
        if is_prime[p] and p not in found_numbers:
            missing_primes.append(p)

    if missing_primes:
        print(f"❌ Missing primes: {len(missing_primes)}")
        print(f"First few missing primes: {missing_primes[:10]}")
    else:
        print("✔ No primes are missing (for odd primes < n_end)")

    if composites_found:
        print(f"❌ Composites detected in output: {len(composites_found)}")
        print(f"First few composites: {composites_found[:10]}")
    else:
        print("✔ No composites detected in output")

def main():
    n_start = 10000
    n_end = n_start + 2000
    run(n_start, n_end)

if __name__ == "__main__":
    main()
